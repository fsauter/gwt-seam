#summary Getting Started with Seam GWTP Dispatch.
#labels Phase-Deploy,Featured,Phase-Implementation,GWTP,Dispatch

 * [#Notice Notice]
 * [#The_Configuration The Configuration]
 * [#The_action The Action]
 * [#The_handler The Handler]
 * [#The_validator The Validator]
 * [#Restrictions Restrictions]

== Notice ==

You should already be familiar with the [http://code.google.com/p/gwt-platform/wiki/GettingStartedDispatch GWTP Dispatch Module] then follow the steps on GettingStartedGWTRPC.

== The configuration == 

Create the following component:

{{{
@Name("gwtpDispatchConfiguration")
public class SeamDispatchConfiguration implements DispatchConfiguration {

	@Override
	public String getEndPoint() {
		return DispatchConfiguration.DEFAULT_ENDPOINT;
	}

	@Override
	public void configureHandlers(HandlerRegistry handlerRegistry) {
		handlerRegistry.bindHandler(HelloWorldAction.class, HelloWorldHandler.class, LoggedInActionValidator.class);
	}

}
}}}

Please be aware of the `@Name("gwtpDispatchConfiguration")` annotation (it has to be this name and not any other). This component is equivalent to [http://code.google.com/p/gwt-platform/source/browse/gwtp-core/gwtp-dispatch-server/src/main/java/com/gwtplatform/dispatch/server/guice/HandlerModule.java GWTP's Guice Handler Module].

_Note: `getEndPoint` has no effect yet. But later on you'll be able to set your custom endpoint._

== The action ==
_Only thing to know: The serviceName/endpoint must be `seam/resource/gwtp`!_

{{{
@GenDispatch(serviceName="seam/resource/gwtp", isSecure=false)
public class HelloWorld {

	@In(1) String name;
	
	@Out(1) String greeting;
}
}}}

== The handler ==
It is important that this handler is annotated with `@Name` to tell anybody (particularly seam) that this is a component which can be managed by seam. The `ScopeType` should be Application so seam does not have to create each time a new instance

{{{ 
@Name("helloWorldHandler")
@Scope(ScopeType.APPLICATION)
public class HelloWorldHandler implements ActionHandler<HelloWorldAction, HelloWorldResult> {

	@Override
	public HelloWorldResult execute(HelloWorldAction action, ExecutionContext context) throws ActionException {
		HelloWorldResult result = new HelloWorldResult("Hello " + action.getName() + "!");
		return result;
	}

	@Override
	public void undo(HelloWorldAction action, HelloWorldResult result, ExecutionContext context) throws ActionException {
		// Nothing to do.
	}

	@Override
	public Class<HelloWorldAction> getActionType() {
		return HelloWorldAction.class;
	}
}
}}}


== The validator == 
It is important that this validator is also annotated with `@Name`.

The great thing is, you've got access to all contexts (e.g. you could say `@In MyCompontent myComponent` etc.)

{{{
@Name("loggedInActionValidator")
@Scope(ScopeType.APPLICATION)
public class LoggedInActionValidator implements ActionValidator {
	
	@Override
	public boolean isValid(Action<? extends Result> action) throws ActionException {
		return Identity.instance().isLoggedIn();
	}

}
}}}

== Restrictions ==

The seam implementation does not provide a way for Automatic XSRF attack detection yet.