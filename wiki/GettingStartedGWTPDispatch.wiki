#summary Getting Started with Seam GWTP Dispatch.
#labels Phase-Deploy,Featured,Phase-Implementation,GWTP,Dispatch

<wiki:toc max_depth="2" />

== Notice ==

You should already be familiar with the [http://code.google.com/p/gwt-platform/wiki/GettingStartedDispatch GWTP Dispatch Module] and a working GWTP project skeleton in your src folder which inherits the GWTP Dispatch Module.

== Setting up server ==

 # Copy (override) gwt-servlet.jar to EAR project, lib folder. (this jar is from gwt and not from seam)
 # download gwt-seam.jar from the download section 
 # Add gwt-seam.jar to 
   * your lib folder 
   * the build path
   * the deployed ear jars

== The configuration == 

Create the following component:

{{{
@Name("gwtpDispatchConfiguration")
@SecurityCookieFilterConfig(filterClass = HttpSessionSecurityCookieFilter.class, cookieName = "MYCOOKIE")
public class SeamDispatchConfiguration implements DispatchConfiguration {

	@Override
	public void configureHandlers(HandlerRegistry handlerRegistry) {
		handlerRegistry.bindHandler(HelloWorldAction.class, HelloWorldHandler.class, LoggedInActionValidator.class);
	}

}
}}}

Please be aware of the `@Name("gwtpDispatchConfiguration")` annotation (it has to be this name and not any other). This component is equivalent to [http://code.google.com/p/gwt-platform/source/browse/gwtp-core/gwtp-dispatch-server/src/main/java/com/gwtplatform/dispatch/server/guice/HandlerModule.java GWTP's Guice Handler Module].

== The action and result ==
Only thing to know: The serviceName/endpoint have to be `seam/resource/gwtp` unless you've set your own CustomEndpoint. 

{{{
@GenDispatch(serviceName="seam/resource/gwtp", isSecure=false)
public class HelloWorld {

	@In(1) String name;
	
	@Out(1) String greeting;
}
}}}

== The handler ==
It is important that this handler is annotated with `@Name` to tell anybody (particularly seam) that this is a component which can be managed by seam. The `ScopeType` should be Application so seam does not have to create each time a new instance

{{{ 
@Name("helloWorldHandler")
@Scope(ScopeType.APPLICATION)
public class HelloWorldHandler implements ActionHandler<HelloWorldAction, HelloWorldResult> {

	@Override
	public HelloWorldResult execute(HelloWorldAction action, ExecutionContext context) throws ActionException {
		HelloWorldResult result = new HelloWorldResult("Hello " + action.getName() + "!");
		return result;
	}

	@Override
	public void undo(HelloWorldAction action, HelloWorldResult result, ExecutionContext context) throws ActionException {
		// Nothing to do.
	}

	@Override
	public Class<HelloWorldAction> getActionType() {
		return HelloWorldAction.class;
	}
}
}}}


== The validator == 
It is important that this validator is also annotated with `@Name`.

The great thing is, you've got access to all contexts (e.g. you could say `@In MyCompontent myComponent` etc.)

{{{
@Name("loggedInActionValidator")
@Scope(ScopeType.APPLICATION)
public class LoggedInActionValidator implements ActionValidator {
	
	@Override
	public boolean isValid(Action<? extends Result> action) throws ActionException {
		return Identity.instance().isLoggedIn();
	}

}
}}}

== Protecting against XSRF attacks  ==

To protect your application against XSRF attacks, as described in <a href="http://groups.google.com/group/Google-Web-Toolkit/web/security-for-gwt-applications">Security for GWT Applications </a>, you have to specify the name of the security cookie you want to use. Do this by binding a string constant annotated with `@SecurityCookie` both on the client and on the server. On the client, you can do this in the `configure()` method of any of your client modules. On the server side, you can do it in your `configureServlets` method of your `servletModule`. The code to do this is:
{{{
    bindConstant().annotatedWith( SecurityCookie.class ).to("MYCOOKIE");
}}}

You should also make sure your `Action.isSecured` methods return `true` for the actions you want to secure against XSRF attacks. One way to do this is to have your actions inherit from `ActionImpl`.

The cookie should contain a session-dependent random number that cannot be easily guessed by an attacker. You can set this cookie yourself as soon as the page is loaded, or you can use the `"JSESSIONID"` cookie, which can be easily enabled on a Tomcat server or on Google !AppEngine.

If you don't want to use the `"JSESSIONID"` cookie, say because you don't want to enable it on !AppEngine, then you can add either `HttpSessionSecurityCookieFilter` or `RandomSessionSecurityCookieFilter` to your list of filters. To do so, add the following line at the top of your `configureServlets` method:
{{{
    filter("*.html").through( HttpSessionSecurityCookieFilter.class );
}}}
Note that you will have to make sure your application `html` file is not served as a static page. To do this, add this to your `appengine-web.xml`:
{{{
<static-files>
    <exclude path="/**.html" />
</static-files>
}}}